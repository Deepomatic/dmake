#!/bin/bash
#
# Usage:
# dmake_build_base_docker PROJECT_DIR
#                         BUILD_DIR \
#                         ROOT_IMAGE_NAME \
#                         ROOT_IMAGE_DIGEST \
#                         DOCKER_IMAGE_NAME \
#                         DOCKER_IMAGE_TAG \
#                         DMAKE_DIGEST \
#                         PUSH_IMAGE
#
# Result:
# Will build and cache the base docker images with libs.

test "${DMAKE_DEBUG}" = "1" && set -x

# allow logging from functions that return values by output
exec 3>&1
function log() {
  echo "$@" >&3
}

if [ $# -ne 8 ]; then
    dmake_fail "$0: Wrong arguments"
    log "exit 1"
    exit 1
fi

set -e

PROJECT_DIR=$1; shift
BUILD_DIR=$1; shift
ROOT_IMAGE_NAME=$1; shift
ROOT_IMAGE_DIGEST=$1; shift
DOCKER_IMAGE_NAME=$1; shift
DOCKER_IMAGE_TAG=$1; shift
DMAKE_DIGEST=$1; shift
PUSH_IMAGE=$1; shift


function docker_get_image_id() {
  docker image ls "$1" --format '{{.ID}}'
}

BASE_IMAGE="${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}"
ROOT_IMAGE_NAME="${ROOT_IMAGE_NAME%:*}"  # strip tag if exists: we use the digest instead

if [[ "${DOCKER_IMAGE_NAME}" =~ .+/.+ ]]; then
  REMOTE_IMAGE=1
else
  REMOTE_IMAGE=0
fi

if [[ ${REMOTE_IMAGE} == 1 && "${DMAKE_PUSH_BASE_IMAGE:-0}" != "0" && "${PUSH_IMAGE}" == "1" ]]; then
  DO_PUSH_IMAGE=1
else
  DO_PUSH_IMAGE=0
fi

function docker_maybe_push_image() {
  if [[ ${DO_PUSH_IMAGE} == 1 ]]; then
    log "Pushing ${BASE_IMAGE}"
    docker push ${BASE_IMAGE}
  fi
}

# Avoid multiple rebuilds of the same base image in parallel
LOCK="/tmp/dmake-build-docker-base-image-${BASE_IMAGE//\//_}.lock"  # replace `/` by `_` in base image name
LOCK_TIMEOUT=600
if command -v flock>/dev/null 2>&1; then
  LOCK=${LOCK}.flock
  exec 9>${LOCK}
  trap "rm -f ${LOCK}" INT TERM EXIT
  flock --exclusive --timeout ${LOCK_TIMEOUT} 9
elif command -v lockfile >/dev/null 2>&1; then
    if [ ! -z "${DMAKE_TMP_DIR}" ]; then
        echo ${LOCK} >> ${DMAKE_TMP_DIR}/files_to_remove.txt
    fi
    trap "rm -f ${LOCK}" INT TERM EXIT
    lockfile -1 -l ${LOCK_TIMEOUT} ${LOCK}
fi


if [ "${DMAKE_FORCE_BASE_IMAGE_BUILD:-false}" = "false" ]; then
  log "Checking cache for docker base image (${BASE_IMAGE})"
  # Check if base image exists locally
  BASE_IMAGE_ID=$(docker_get_image_id $BASE_IMAGE)

  # then check remotely
  if [[ -z "${BASE_IMAGE_ID}" && ${REMOTE_IMAGE} == 1 ]]; then
    docker pull $BASE_IMAGE || :
    BASE_IMAGE_ID=$(docker_get_image_id $BASE_IMAGE)
  fi
else
  log "Docker base image build forced by \$DMAKE_FORCE_BASE_IMAGE_BUILD=${DMAKE_FORCE_BASE_IMAGE_BUILD} for docker base image (${BASE_IMAGE})"
fi

# build base image if needed
if [ -z "${BASE_IMAGE_ID}" ]; then
    log "Docker base image not found in cache, building it (${BASE_IMAGE})"

    if [ `uname` = "Darwin" ] && [ ! -z "${DMAKE_SSH_KEY}" ]; then
        OTHER_OPTS="-v ${DMAKE_SSH_KEY}:/key"
    fi

    if [ ! -z "$SSH_AUTH_SOCK" ]; then
        SSH_AUTH_SOCK_VOLUME="-v $SSH_AUTH_SOCK:$SSH_AUTH_SOCK"
    fi

    docker image build -f "${BUILD_DIR}/Dockerfile" "${PROJECT_DIR}" --tag ${BASE_IMAGE}

    # Then push if asked to
    docker_maybe_push_image
else
    log "Docker base image found in cache, using it (${BASE_IMAGE})"
fi
